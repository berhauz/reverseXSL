<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_14) on Mon Dec 24 16:47:35 CET 2012 -->
<TITLE>
Parser
</TITLE>

<META NAME="date" CONTENT="2012-12-24">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Parser";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Parser.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../com/reverseXSL/parser/Definition.html" title="class in com.reverseXSL.parser"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../com/reverseXSL/parser/Parser.ExceptionListIterator.html" title="class in com.reverseXSL.parser"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?com/reverseXSL/parser/Parser.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Parser.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
com.reverseXSL.parser</FONT>
<BR>
Class Parser</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>com.reverseXSL.parser.Parser</B>
</PRE>
<HR>
<DL>
<DT><PRE>public final class <B>Parser</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
Provides the methods to translate input character streams into XML documents.
 The parsing is based on <A HREF="../../../com/reverseXSL/parser/Definition.html" title="class in com.reverseXSL.parser"><CODE>DEF files</CODE></A>.
 <p>
 Please refer to the MS-Word documentation 'ReverseXSL DEF file specs.doc' for a complete description of the 
 Definition objects and file syntaxes handled by this parser. 
 <br>See also <A HREF="../../../com/reverseXSL/parser/Definition.html" title="class in com.reverseXSL.parser"><CODE>Definition</CODE></A>.
 </p><p>
 Design Note: Given the simplicity of a parsing 
 environment (simply comprising a DEF file) we have not associated a ParserFactory to the Parser itself. 
 One shall simply 
 instantiate a parser via the constructor:<br>
 <code>myParser = new <A HREF="../../../com/reverseXSL/parser/Parser.html#Parser(com.reverseXSL.parser.Definition, int, int)"><CODE>Parser</CODE></A>(def, maxFatal, maxExceptions);</code><br>
 and then call it as often as desired, repeating in this case the same transformation, each time on a new message, as in:<br>
 <code><A HREF="../../../com/reverseXSL/parser/Parser.html#parse(java.lang.String, java.lang.String, int)"><CODE>myParser.parse</CODE></A>(dataIn, ...);</code><br>
 Note that the parse() method in proper returns a count of exceptions. Additional methods are used to inspect
 results and get a rendering of the output, only as an XML-formatted document in the present version (additional 
 output formats 
 could be added in future releases). A Parser instance is a stateful object, whose state is reset 
 at the start of any new parse() method call.
 </p>
 <p>The present class provides a fairly low-level API for reverse XSL transformations. Please consider the 
 <A HREF="../../../com/reverseXSL/transform/TransformerFactory.html" title="class in com.reverseXSL.transform"><CODE>TransformerFactory</CODE></A> and 
 <A HREF="../../../com/reverseXSL/transform/Transformer.html" title="class in com.reverseXSL.transform"><CODE>Transformer objects</CODE></A> for improved productivity.
 </p>
<P>

<P>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/reverseXSL/parser/Parser.ExceptionListIterator.html" title="class in com.reverseXSL.parser">Parser.ExceptionListIterator</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This Inner Class sub-classes a ListIterator such as to support methods 
 more specific to the handling of the Exception list recorded by the parser.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../com/reverseXSL/parser/Parser.html#Parser()">Parser</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Required but not much useful as such.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../com/reverseXSL/parser/Parser.html#Parser(com.reverseXSL.parser.Definition, int, int)">Parser</A></B>(<A HREF="../../../com/reverseXSL/parser/Definition.html" title="class in com.reverseXSL.parser">Definition</A>&nbsp;msgDef,
       int&nbsp;maxFatEx,
       int&nbsp;maxEx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initialises a new Parser object with a reference Definition and Exception handling parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../com/reverseXSL/parser/Parser.html#Parser(com.reverseXSL.parser.Definition, int, int, int)">Parser</A></B>(<A HREF="../../../com/reverseXSL/parser/Definition.html" title="class in com.reverseXSL.parser">Definition</A>&nbsp;msgDef,
       int&nbsp;maxFatEx,
       int&nbsp;maxEx,
       int&nbsp;maxMisMatch)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variant of <A HREF="../../../com/reverseXSL/parser/Parser.html#Parser(com.reverseXSL.parser.Definition, int, int)"><CODE>Parser(Definition, int, int)</CODE></A> that allows to 
 set the max number of successive segment/element matching failures after which the 
 parser will attempt to 'backtrack'.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/reverseXSL/parser/Parser.html#adjustExceptionsLineOffsets(int)">adjustExceptionsLineOffsets</A></B>(int&nbsp;adjustment)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adjust the line offsets of all recorded exceptions by adding the given adjustment value to
 all line offsets (relevant whenever the input message is set of lines).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/reverseXSL/parser/Parser.ExceptionListIterator.html" title="class in com.reverseXSL.parser">Parser.ExceptionListIterator</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/reverseXSL/parser/Parser.html#exceptionIterator()">exceptionIterator</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Provides a List Iterator on the Array List of recorded exceptions (stored
 in parser state next to a <A HREF="../../../com/reverseXSL/parser/Parser.html#parse(java.lang.String, java.lang.String, int)"><CODE>parse(String, String, int)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/reverseXSL/parser/Parser.html#extractCompositeValue(java.lang.StringBuffer, java.util.regex.Pattern)">extractCompositeValue</A></B>(java.lang.StringBuffer&nbsp;sb,
                      java.util.regex.Pattern&nbsp;ptrn)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Magic procedure able to return the concatenated value of all capturing groups in a 
 complex pattern applied to a string (the pattern can match once or more times).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/reverseXSL/parser/Parser.html#extractCompositeValue(java.lang.StringBuffer, java.util.regex.Pattern, java.lang.String)">extractCompositeValue</A></B>(java.lang.StringBuffer&nbsp;sb,
                      java.util.regex.Pattern&nbsp;ptrn,
                      java.lang.String&nbsp;sep)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Magic procedure able to return the concatenated value of all capturing groups in a 
 complex pattern applied to a string (the pattern can match once or more times).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.io.StringWriter</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/reverseXSL/parser/Parser.html#getXML(boolean, boolean)">getXML</A></B>(boolean&nbsp;withRAW,
       boolean&nbsp;indent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Provides an XML rendering of the tagged message as resulting from parsing, i.e.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/reverseXSL/parser/Parser.html#parse(java.lang.String, java.io.LineNumberReader, int)">parse</A></B>(java.lang.String&nbsp;msgID,
      java.io.LineNumberReader&nbsp;dataIn,
      int&nbsp;startLineNb)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parses an input character stream using a <CODE>LineNumberReader</CODE>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/reverseXSL/parser/Parser.html#parse(java.lang.String, java.lang.String, int)">parse</A></B>(java.lang.String&nbsp;msgID,
      java.lang.String&nbsp;dataIn,
      int&nbsp;startLineNb)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variant parse method starting from a string and falling back onto 
 the other <A HREF="../../../com/reverseXSL/parser/Parser.html#parse(java.lang.String, java.io.LineNumberReader, int)"><CODE>parse(String, LineNumberReader, int)</CODE></A> method 
 whenever the system discovers that the <CODE>cut function</CODE>
 at the Message level is <code>CUT-ON-NL</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/reverseXSL/parser/Parser.html#removeNonRepeatableNilOptionalElements(boolean)">removeNonRepeatableNilOptionalElements</A></B>(boolean&nbsp;tf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method must be called before parsing in itself (i.e.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/reverseXSL/parser/Parser.html#setBaseNamespace(java.lang.String)">setBaseNamespace</A></B>(java.lang.String&nbsp;bns)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the base XML namespace for every following <A HREF="../../../com/reverseXSL/parser/Parser.html#parse(java.lang.String, java.io.LineNumberReader, int)"><CODE>parse(String, LineNumberReader, int)</CODE></A>
 invocation followed by <A HREF="../../../com/reverseXSL/parser/Parser.html#getXML(boolean, boolean)"><CODE>getXML(boolean, boolean)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/reverseXSL/parser/Parser.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dumps an overview of the parser state into a text string.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Parser()"><!-- --></A><H3>
Parser</H3>
<PRE>
public <B>Parser</B>()</PRE>
<DL>
<DD>Required but not much useful as such. 
 <p>
 This method was made public just for
 the sake of invoking diverse utility methods notably in RegexCheck and Definition.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/reverseXSL/parser/Parser.html#Parser(com.reverseXSL.parser.Definition, int, int)"><CODE>Parser(Definition, int, int)</CODE></A>, 
<A HREF="../../../com/reverseXSL/parser/Parser.html#Parser(com.reverseXSL.parser.Definition, int, int, int)"><CODE>Parser(Definition, int, int, int)</CODE></A></DL>
</DL>
<HR>

<A NAME="Parser(com.reverseXSL.parser.Definition, int, int)"><!-- --></A><H3>
Parser</H3>
<PRE>
public <B>Parser</B>(<A HREF="../../../com/reverseXSL/parser/Definition.html" title="class in com.reverseXSL.parser">Definition</A>&nbsp;msgDef,
              int&nbsp;maxFatEx,
              int&nbsp;maxEx)</PRE>
<DL>
<DD>Initialises a new Parser object with a reference Definition and Exception handling parameters.
 The <A HREF="../../../com/reverseXSL/parser/Parser.html#parse(java.lang.String, java.io.LineNumberReader, int)"><CODE>parse(String, LineNumberReader, int)</CODE></A> method can then be repetitively invoked on diverse
 input message data.
 <p>
 The maximum number of successive missed-element-matching before backtracking is 3 by default.
 See <A HREF="../../../com/reverseXSL/parser/Parser.html#Parser(com.reverseXSL.parser.Definition, int, int, int)"><CODE>Parser(Definition, int, int, int)</CODE></A>.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>msgDef</CODE> - the message Definition object to use for parsing<DD><CODE>maxFatEx</CODE> - the max number of fatal exceptions that will be recorded before being thrown<DD><CODE>maxEx</CODE> - the max number of all kinds of exceptions (including fatal ones) that will 
                                                be recorded before being thrown<DT><B>See Also:</B><DD><A HREF="../../../com/reverseXSL/parser/Definition.html" title="class in com.reverseXSL.parser"><CODE>Definition</CODE></A></DL>
</DL>
<HR>

<A NAME="Parser(com.reverseXSL.parser.Definition, int, int, int)"><!-- --></A><H3>
Parser</H3>
<PRE>
public <B>Parser</B>(<A HREF="../../../com/reverseXSL/parser/Definition.html" title="class in com.reverseXSL.parser">Definition</A>&nbsp;msgDef,
              int&nbsp;maxFatEx,
              int&nbsp;maxEx,
              int&nbsp;maxMisMatch)</PRE>
<DL>
<DD>Variant of <A HREF="../../../com/reverseXSL/parser/Parser.html#Parser(com.reverseXSL.parser.Definition, int, int)"><CODE>Parser(Definition, int, int)</CODE></A> that allows to 
 set the max number of successive segment/element matching failures after which the 
 parser will attempt to 'backtrack'. 
 <p>
 Backtracking means that the Parser will give-up with
 the current input message element (i.e. skip data and leave it un-tagged as RAW input data), 
 jump back (i.e. 'backtrack) to the last unmatched definition,
 and attempt to resume parsing from there.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>msgDef</CODE> - the message Definition object to use for parsing<DD><CODE>maxFatEx</CODE> - the max number of fatal exceptions that will be recorded before being thrown<DD><CODE>maxEx</CODE> - the max number of all kinds of exceptions (including fatal ones) that will 
                                                be recorded before being thrown<DD><CODE>maxMisMatch</CODE> - the maximum number of successive missed-element-matching after which the parser
                                                will attempt to resume parsing by skipping input data 
                                                and backtracking into the definition.<DT><B>See Also:</B><DD><A HREF="../../../com/reverseXSL/parser/Definition.html" title="class in com.reverseXSL.parser"><CODE>Definition</CODE></A></DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="adjustExceptionsLineOffsets(int)"><!-- --></A><H3>
adjustExceptionsLineOffsets</H3>
<PRE>
public void <B>adjustExceptionsLineOffsets</B>(int&nbsp;adjustment)</PRE>
<DL>
<DD>Adjust the line offsets of all recorded exceptions by adding the given adjustment value to
 all line offsets (relevant whenever the input message is set of lines). The adjustment can be either
 positive or negative and is actually added to exceptions' line offsets.<br>
 Consistency rule: Existing line offsets which may yield a negative value next to adjustment are not updated.
 The use of this method in a proper message parsing context shall never yield such case.
 <p>
 This method is a facility to perform the parsing of a input message on the text message body
 part alone (e.g. without the message's header lines), and then report line offsets of any parsing errors
 relative to the very beginning of the message, header lines included. If an input interchange contains
 several messages, this facility helps parsing each message in turn but reports offsets with regard to 
 the global interchange.
 </p>
 <p>Release note: a future release is planned that will de-pollute and 
 normalize well-known EDI formats like EDIFACT and X12
 before Parsing, and make segment offsets like line offsets.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>adjustment</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="exceptionIterator()"><!-- --></A><H3>
exceptionIterator</H3>
<PRE>
public <A HREF="../../../com/reverseXSL/parser/Parser.ExceptionListIterator.html" title="class in com.reverseXSL.parser">Parser.ExceptionListIterator</A> <B>exceptionIterator</B>()</PRE>
<DL>
<DD>Provides a List Iterator on the Array List of recorded exceptions (stored
 in parser state next to a <A HREF="../../../com/reverseXSL/parser/Parser.html#parse(java.lang.String, java.lang.String, int)"><CODE>parse(String, String, int)</CODE></A>.
 <p>
 Note that the last exception that possibly caused the 
 MaxFatal or MaxAllExceptions counts to be exceeded (and thrown) is also
 recorded.
 </p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>an extended ListIterator supporting extra methods for improved
                        iteration through a <A HREF="../../../com/reverseXSL/parser/Parser.html" title="class in com.reverseXSL.parser"><CODE>Parser</CODE></A> state.</DL>
</DD>
</DL>
<HR>

<A NAME="extractCompositeValue(java.lang.StringBuffer, java.util.regex.Pattern)"><!-- --></A><H3>
extractCompositeValue</H3>
<PRE>
public int <B>extractCompositeValue</B>(java.lang.StringBuffer&nbsp;sb,
                                 java.util.regex.Pattern&nbsp;ptrn)</PRE>
<DL>
<DD>Magic procedure able to return the concatenated value of all capturing groups in a 
 complex pattern applied to a string (the pattern can match once or more times). The procedure 
 ignores the sub-capturing-groups.
 (i.e. ignores nested Capturing groups) that would create data duplication in the result.
 <p>
 NOTE: This method was made public just for the sake of being invoked by the RegexCheck tool.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sb</CODE> - string buffer containing original string and returned with the extracted result<DD><CODE>ptrn</CODE> - pattern of reference with capturing groups
<DT><B>Returns:</B><DD>the offset in the original string of the first byte of the extracted part</DL>
</DD>
</DL>
<HR>

<A NAME="extractCompositeValue(java.lang.StringBuffer, java.util.regex.Pattern, java.lang.String)"><!-- --></A><H3>
extractCompositeValue</H3>
<PRE>
public int <B>extractCompositeValue</B>(java.lang.StringBuffer&nbsp;sb,
                                 java.util.regex.Pattern&nbsp;ptrn,
                                 java.lang.String&nbsp;sep)</PRE>
<DL>
<DD>Magic procedure able to return the concatenated value of all capturing groups in a 
 complex pattern applied to a string (the pattern can match once or more times). The procedure 
 ignores the sub-capturing-groups.
 (i.e. ignores nested Capturing groups) that would create data duplication in the result.
 <p>
 NOTE: This method was made public just for the sake of being invoked by the RegexCheck tool.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sb</CODE> - string buffer containing original string and returned with the extracted result<DD><CODE>ptrn</CODE> - pattern of reference with capturing groups<DD><CODE>sep</CODE> - separator between multiple capturing group values in the concatenated resulting string
<DT><B>Returns:</B><DD>the offset in the original string of the first byte of the extracted part</DL>
</DD>
</DL>
<HR>

<A NAME="getXML(boolean, boolean)"><!-- --></A><H3>
getXML</H3>
<PRE>
public java.io.StringWriter <B>getXML</B>(boolean&nbsp;withRAW,
                                   boolean&nbsp;indent)
                            throws javax.xml.parsers.ParserConfigurationException,
                                   javax.xml.parsers.FactoryConfigurationError,
                                   javax.xml.transform.TransformerFactoryConfigurationError,
                                   javax.xml.transform.TransformerException</PRE>
<DL>
<DD>Provides an XML rendering of the tagged message as resulting from parsing, i.e. 
 next to a <A HREF="../../../com/reverseXSL/parser/Parser.html#parse(java.lang.String, java.io.LineNumberReader, int)"><CODE>parse(String, LineNumberReader, int)</CODE></A> method call.
 <p>Data and Marks elements whose names start with the special character @ are promoted as
 attributes of the parent element.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>withRAW</CODE> - tells to generate RAW element or not;
                                        i.e. either UnTagged elements else those explicitly tagged as 'RAW'<DD><CODE>indent</CODE> - asks for indentation (only line breaks on elements as true indentation does not work!)
<DT><B>Returns:</B><DD>the XML output in a <CODE>StringWriter</CODE>
<DT><B>Throws:</B>
<DD><CODE>javax.xml.parsers.FactoryConfigurationError</CODE>
<DD><CODE>javax.xml.parsers.ParserConfigurationException</CODE>
<DD><CODE>javax.xml.transform.TransformerFactoryConfigurationError</CODE>
<DD><CODE>javax.xml.transform.TransformerException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="parse(java.lang.String, java.io.LineNumberReader, int)"><!-- --></A><H3>
parse</H3>
<PRE>
public int <B>parse</B>(java.lang.String&nbsp;msgID,
                 java.io.LineNumberReader&nbsp;dataIn,
                 int&nbsp;startLineNb)
          throws java.io.IOException,
                 ParserException</PRE>
<DL>
<DD>Parses an input character stream using a <CODE>LineNumberReader</CODE>. This implementation is able to
 trace line offsets in <CODE>Parser Exceptions</CODE>
 whenever the MSG level cut-function is actually CUT-ON-NL.
 <p>
 The parsing is successful when no exceptions are thrown <u>and</u> the returned number of 
 recorded exceptions is 0.
 <p>
 Next to parsing, the XML document can be generated using:<br>
 <code><A HREF="../../../com/reverseXSL/parser/Parser.html#getXML(boolean, boolean)"><CODE>getXML(boolean, boolean)</CODE></A></code>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>msgID</CODE> - a message ID (will be recorded in exceptions and traced)<DD><CODE>dataIn</CODE> - the line number reader, possibly reset(), so that readLine() will get the very first characters<DD><CODE>startLineNb</CODE> - the line number to assume <u>next</u> to the first dataIn.readLine()
<DT><B>Returns:</B><DD>the total count of exceptions that were recorded
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>ParserException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="parse(java.lang.String, java.lang.String, int)"><!-- --></A><H3>
parse</H3>
<PRE>
public int <B>parse</B>(java.lang.String&nbsp;msgID,
                 java.lang.String&nbsp;dataIn,
                 int&nbsp;startLineNb)
          throws java.io.IOException,
                 ParserException</PRE>
<DL>
<DD>Variant parse method starting from a string and falling back onto 
 the other <A HREF="../../../com/reverseXSL/parser/Parser.html#parse(java.lang.String, java.io.LineNumberReader, int)"><CODE>parse(String, LineNumberReader, int)</CODE></A> method 
 whenever the system discovers that the <CODE>cut function</CODE>
 at the Message level is <code>CUT-ON-NL</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>msgID</CODE> - a message ID<DD><CODE>dataIn</CODE> - input string data message<DD><CODE>startLineNb</CODE> - starting line number (e.g. from the original message that
                                                also possibly contained a header/envelope)
<DT><B>Returns:</B><DD>the total count of exceptions that were recorded
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>ParserException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="removeNonRepeatableNilOptionalElements(boolean)"><!-- --></A><H3>
removeNonRepeatableNilOptionalElements</H3>
<PRE>
public void <B>removeNonRepeatableNilOptionalElements</B>(boolean&nbsp;tf)</PRE>
<DL>
<DD>This method must be called before parsing in itself (i.e. <A HREF="../../../com/reverseXSL/parser/Parser.html#parse(java.lang.String, java.io.LineNumberReader, int)"><CODE>parse(String, LineNumberReader, int)</CODE></A>)
 and would cause (if set TRUE) to remove all data elements with a NIL value
 that are optional or conditional elements,
 <b>and</b> whose matching definition indicates that the element is non repeatable (i.e. ACC 1),
 <b>and</b> whose minimum size requirement is >0.
 <p>
 This function is actually quite useful on messages based on the principle of positional data elements
 within 'segments' (e.g. EDIFACT, TRADACOMS, X12, etc.). Indeed, most positions (think 'slots')
 in such segments are occupied by optional/conditional data elements, all unique and distinguished by their relative position
 in the 'segment'. Every unoccupied position
 will yield a corresponding NIL data element in XML, that can be suppressed from
 the XML output if this method is set to TRUE.
 <p>
 NIL data elements are supressed only if they have a min/max size
 specification (of the kind <code>[1..15]</code> ) with a minimum of at least 1.
 Obviously, if 0 is an acceptable size, there's no reason to suppress the element.
 <p>
 Moreover, the element must be non-repeatable otherwise there is a risk
 to eat-up first and intermediate elements causing undesirable rank shifts.
 <p>
 The default value is false.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tf</CODE> - new value for the flag</DL>
</DD>
</DL>
<HR>

<A NAME="setBaseNamespace(java.lang.String)"><!-- --></A><H3>
setBaseNamespace</H3>
<PRE>
public final void <B>setBaseNamespace</B>(java.lang.String&nbsp;bns)</PRE>
<DL>
<DD>Sets the base XML namespace for every following <A HREF="../../../com/reverseXSL/parser/Parser.html#parse(java.lang.String, java.io.LineNumberReader, int)"><CODE>parse(String, LineNumberReader, int)</CODE></A>
 invocation followed by <A HREF="../../../com/reverseXSL/parser/Parser.html#getXML(boolean, boolean)"><CODE>getXML(boolean, boolean)</CODE></A>. 
 <p>
 This namespace is not reset in between parse(...) calls.
 </p><p>
 The default namespace is "http://www.reverseXSL.com/FreeParser".
 Calling this method with null or empty arguments does reset the namespace to the
 default (as if setBasenamespace() was never invoked). Note that the namespace 
 can be set via the java API alse the <b>SET BASENAMESPACE</b> statement in DEF files. In case
 both are used, the API takes precedence.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>bns</CODE> - the namespace that applies to this parser instance, e.g. "http://www.reverseXSL.com/Cargo"</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>()</PRE>
<DL>
<DD>Dumps an overview of the parser state into a text string. 
 Useful for debugging Definitions under development and testing their 
 effect on sample messages.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>toString</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>complete parser state dump as text.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Parser.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../com/reverseXSL/parser/Definition.html" title="class in com.reverseXSL.parser"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../com/reverseXSL/parser/Parser.ExceptionListIterator.html" title="class in com.reverseXSL.parser"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?com/reverseXSL/parser/Parser.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Parser.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
